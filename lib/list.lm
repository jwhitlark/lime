(define empty (quote ()))

(define list? (compose not atom?))

(define (init l)
  (if (= 1 (len l))
      empty
      (cons (head l) (init (tail l)))))

(define (last l)
  (elem (len l) l))

(define (map f l)
  (if (empty? l)
      empty
      (cons (f (head l)) (map f (tail l)))))

(define (filter p l)
  (if (empty? l)
      empty
      (if (p (head l))
          (cons (head l) (filter p (tail l)))
          (filter p (tail l)))))

(define (fold f i l)
  (if (empty? l)
      i
      (fold f (f i (head l)) (tail l))))

(define (for-each f l)
  (if (empty? l)
      nil
      (begin
        (f (head l))
        (for-each f (tail l)))))

(define (take n l)
  (if (= n 0)
      empty
      (cons (head l) (take (- n 1) (tail l)))))

(define (drop n l)
  (if (empty? l)
      empty
      (if (= 0 n)
          l
          (drop (- n 1) (tail l)))))

(define (take-while p l)
  (if (or (empty? l) (not (p (head l))))
      empty
      (cons (head l) (take-while p (tail l)))))

(define (drop-while p l)
  (if (empty? l)
      empty
      (if (p (head l))
          (drop-while p (tail l))
          l)))    

(define (zip-with f l1 l2)
  (if (or (empty? l1) (empty? l2))
      empty
      (cons (f (head l1) (head l2))
            (zip-with f (tail l1) (tail l2)))))

(define zip (zip-with list))

(define (count x l) 
  (len (filter (= x) l)))

(define (count-if p l)
  (len (filter p l)))

(define (all l)
  (if (empty? l)
      true
      (and (head l) (all (tail l)))))

(define (any l)
  (if (empty? l)
      false
      (or (head l) (any (tail l)))))

(define (contains x l)
  (and (not (empty? l)) 
       (or (= x (head l)) 
           (contains x (tail l)))))

(define (concat l1 l2)
  (begin
    (define c l1)
    (for-each
      (push-back! c)
      l2)
    c))

(define (concat! &l1 l2)
  (for-each
    (push-back! l1)
  l2))

(define (swap! &l i j)
  (begin
    (define tmp (elem i l))
    (set-elem! l i (elem j l))
    (set-elem! l j tmp)))

(define (reverse l)
  (begin
    (define r empty)
    (for-each (push-front! r) l)
    r))

(define (reverse! &l)
  (begin
    (define n (len l))
    (for-each
      (lambda (i)
        (begin
          (define j (+ 1 (- n i)))
          (swap! l i j)))
      (range 1 (/ n 2)))))

(define (shuffle! &l)
  (begin
    (define n (len l))
    (for-each
      (lambda (i)
        (swap! l i (+ i (randint 0 (- n i)))))
      (range 1 n))))

(define (shuffle l)
  (begin
    (define s l)
    (shuffle! s)
    s))

(define (sample k l)
  (begin
    (define n (len l))
    (define s empty)
    (for-each
      (lambda (i)
        (if (<= (randint 1 (+ 1 (- n i)))
                (- k (len s)))
            (push-back! s (elem i l))
            nil))
      (range 1 n))
    s))

(define (sort-by cmp l)
  (if (<= (len l) 1)
      l
      (begin
        (define n (len l))
        (define p (randint 1 n))
        (define pv (elem p l))
        (define lesser empty)
        (define greater empty)
        (for-each
          (lambda (i)
            (begin
              (define x (elem i l))
              (if (cmp x pv)    
                  (push-back! lesser x)
                  (push-back! greater x))))
          (filter (!= p) (range 1 (len l))))
        (concat (sort-by cmp lesser)
                (cons pv (sort-by cmp greater))))))

(define (partition! cmp &l left right p)
  (begin
    (define pv (elem p l))
    (swap! l p right)
    (define q left)
    (for-each
      (lambda (i)
        (if (cmp (elem i l) pv)
            (begin 
              (swap! l i q)
              (set! q (+ q 1)))
            nil))
      (range left (- right 1)))
    (swap! l q right)
    q))

(define (quicksort! cmp &l left right)
  (if (< left right)
    (begin
      (define p (randint left right))
      (define p' (partition! cmp l left right p))
      (quicksort! cmp l left (- p' 1))
      (quicksort! cmp l (+ p' 1) right))
    nil))

(define (sort-by! cmp &l)
  (quicksort! cmp l 1 (len l)))
    
(define (map! f &l)
  (for-each
    (lambda (i)
      (set-elem! l i (f (elem i l))))
    (range 1 (len l))))

(define (filter! p &l)
  (set! l (filter p l)))

(define (take! n &l)
  (do (- (len l) n) 
    (pop-back! l)))

(define (drop! n &l)
  (do n 
    (pop-front! l)))

(define (take-while! p &l)
  (begin
    (define k 0)
    (define i 1)
    (while (p (elem i l))
      (begin
        (set! k (+ k 1))
        (set! i (+ i 1))))
    (do (- (len l) k)
      (pop-back! l))))

(define (drop-while! p &l)
  (while (p (head l))
    (pop-front! l)))
