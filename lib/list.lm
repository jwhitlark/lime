(define empty (quote ()))

(define list? (compose not atom?))

(define (len l)
  (if (empty? l)
      0
      (+ 1 (len (tail l)))))

(define (init l)
  (if (= 1 (len l))
      empty
      (cons (head l) (init (tail l)))))

(define (last l)
  (if (= 1 (len l))
      (head l)
      (last (tail l))))

(define (map f l)
  (if (empty? l)
      empty
      (cons (f (head l)) (map f (tail l)))))

(define (filter p l)
  (if (empty? l)
      empty
      (if (p (head l))
          (cons (head l) (filter p (tail l)))
          (filter p (tail l)))))

(define (fold f i l)
  (if (empty? l)
      i
      (fold f (f i (head l)) (tail l))))

(define (for-each f l)
  (if (empty? l)
      nil
      (begin
        (f (head l))
        (for-each f (tail l)))))

(define (take n l)
  (if (= n 0)
      empty
      (cons (head l) (take (- n 1) (tail l)))))

(define (drop n l)
  (if (empty? l)
      empty
      (if (= 0 n)
          l
          (drop (- n 1) (tail l)))))

(define (take-while p l)
  (if (or (empty? l) (not (p (head l))))
      empty
      (cons (head l) (take-while p (tail l)))))

(define (drop-while p l)
  (if (empty? l)
      empty
      (if (p (head l))
          (drop-while p (tail l))
          l)))    

(define (zip-with f l1 l2)
  (if (or (empty? l1) (empty? l2))
      empty
      (cons (f (head l1) (head l2))
            (zip-with f (tail l1) (tail l2)))))

(define zip (zip-with list))

(define (count x l) 
  (len (filter (= x) l)))

(define (count-if p l)
  (len (filter p l)))

(define (all l)
  (if (empty? l)
      true
      (and (head l) (all (tail l)))))

(define (any l)
  (if (empty? l)
      false
      (or (head l) (any (tail l)))))
